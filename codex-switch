#!/usr/bin/env bash
set -euo pipefail

PROG="codex-switch"

die() {
  echo "error: $*" >&2
  exit 1
}

term_fd() {
  # Prefer stderr for prompts if it's a TTY; otherwise fall back to stdout.
  if [[ -t 2 ]]; then
    echo 2
  else
    echo 1
  fi
}

term_printf() {
  local fd
  fd="$(term_fd)"
  # shellcheck disable=SC2059
  printf "$@" >&"$fd"
}

# (no /dev/tty dependency; prompts use stderr/stdout and input is sanitized)

use_mode() {
  # Modes:
  # - patch (default): update base_url + model_provider inside CODEX_HOME/config.toml, keep other settings (e.g. mcp_servers) intact.
  # - copy: legacy behavior, overwrite CODEX_HOME/config.toml with profile config.toml.
  echo "${CODEX_SWITCH_USE_MODE:-patch}"
}

usage() {
  cat <<'EOF'
codex-switch - switch Codex multi-account configs (config.toml + auth.json)

Usage:
  codex-switch init
  codex-switch list
  codex-switch current
  codex-switch add <profile>
  codex-switch edit <profile>
  codex-switch del <profile>
  codex-switch use <profile>
  codex-switch save <profile>
  codex-switch unify-provider <provider>
  codex-switch rollback
  codex-switch path

Notes:
  - Profiles only include: config.toml + auth.json
  - Default CODEX_HOME: ~/.codex (override by exporting CODEX_HOME)
  - No secret contents are printed; files are treated as opaque blobs.
  - Default switch behavior (CODEX_SWITCH_USE_MODE=patch):
    - Keeps a single CODEX_HOME/config.toml and only patches base_url + model_provider.
    - This preserves other config (e.g. mcp_servers) and helps share history across profiles when provider name is stable.

Environment:
  - CODEX_SWITCH_SHARED_PROVIDER: default provider name used by 'add' when --provider is omitted.
    Use the same provider name across profiles to encourage shared session/history grouping in Codex.
  - CODEX_SWITCH_USE_MODE: "patch" (default) or "copy" (legacy).
EOF
}

usage_add() {
  cat <<'EOF'
Usage:
  codex-switch add <profile> [options]

Options:
  --provider <name>     Provider name used in config.toml (default: <profile> or $CODEX_SWITCH_SHARED_PROVIDER)
  --base-url <url>      base_url for the provider (prompt if missing)
  --auth-copy           Copy current auth.json into profile
  --auth-from <path>    Copy auth.json from another file
  --auth-paste          Paste raw auth.json from stdin (finish with Ctrl-D)
  --auth-edit           Create then open $EDITOR to edit auth.json
  --auth-empty          Create empty auth.json ("{}")
  --copy-auth           Alias of --auth-copy
  --no-copy-auth        Alias of --auth-empty
  --switch              Switch to the new profile after creating it
  --force               Overwrite existing profile directory if exists
  -y, --yes             Accept defaults for prompts

Interactive defaults (no --auth-* given):
  - Prompts for provider + base_url
  - Prompts for API key as "auth:" (input hidden). Press Enter to copy current auth.json instead.

Tip (shared history):
  - Use the same provider name across all profiles (e.g. export CODEX_SWITCH_SHARED_PROVIDER=shared),
    so Codex can group/show sessions consistently across profile switches.
EOF
}

usage_unify_provider() {
  cat <<'EOF'
Usage:
  codex-switch unify-provider <provider> [-y|--yes]

What it does:
  - Rewrites each profile's config.toml so model_provider=<provider>
  - Preserves each profile's base_url by copying from the profile's current provider block
  - Creates a backup of all profile config.toml files under ~/.codex-switch/backups/

Why:
  - Using a shared provider name across profiles helps Codex show history/sessions consistently
    when switching auth/base_url per profile.
EOF
}

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || die "missing required command: $1"
}

have_cmd() {
  command -v "$1" >/dev/null 2>&1
}

prompt() {
  local msg="$1"
  local default="${2:-}"
  local input=""
  local prompt_str
  if [[ -n "$default" ]]; then
    prompt_str="$msg [$default]: "
  else
    prompt_str="$msg: "
  fi

  term_printf "%s" "$prompt_str"
  if [[ -t 0 ]]; then
    # Try readline editing (arrow keys). If unavailable, fall back to plain read.
    if ! IFS= read -r -e input; then
      IFS= read -r input || die "input aborted"
    fi
  else
    IFS= read -r input || die "input aborted"
  fi

  input="$(sanitize_terminal_input "$input")"
  if [[ -z "$input" ]]; then
    echo "$default"
  else
    echo "$input"
  fi
}

prompt_secret() {
  local msg="$1"
  local input=""

  term_printf "%s: " "$msg"
  if [[ -t 0 ]]; then
    IFS= read -r -s input || die "input aborted"
  else
    IFS= read -r -s input || die "input aborted"
  fi
  term_printf "\n"

  echo "$(sanitize_terminal_input "$input")"
}

sanitize_terminal_input() {
  local value="$1"
  local esc=$'\e'

  value="${value//$esc[200~/}"
  value="${value//$esc[201~/}"

  # Strip common escape sequences that can appear when arrow keys / paste are misinterpreted.
  value="$(printf '%s' "$value" | sed $'s/\\x1b\\[[0-9;]*[A-Za-z~]//g; s/\\x1b//g')"
  echo "$value"
}

# NOTE: we intentionally do not toggle bracketed-paste mode.
# Some terminals/wrappers handle it poorly; we instead strip the markers from input.

toml_get_string() {
  local file="$1"
  local key="$2"
  awk -v key="$key" '
    {
      line=$0
      sub(/^[ \t]*/, "", line)
      if (line ~ "^" key "[ \t]*=") {
        if (match(line, /\"([^\"]*)\"/, m)) {
          print m[1]
          exit
        }
      }
    }
  ' "$file" 2>/dev/null || true
}

toml_get_provider_base_url() {
  local file="$1"
  local provider="$2"
  [[ -n "$provider" ]] || return 0

  awk -v p="$provider" '
    BEGIN { inside=0 }
    $0=="[model_providers." p "]" { inside=1; next }
    inside && /^\[/ { exit }
    inside && /^base_url[ \t]*=/ { print; exit }
  ' "$file" 2>/dev/null | sed -n 's/^base_url[[:space:]]*=[[:space:]]*"\([^"]*\)".*/\1/p' | head -n 1 || true
}

codex_native_bin() {
  if [[ -n "${CODEX_SWITCH_CODEX_BIN:-}" ]]; then
    echo "$CODEX_SWITCH_CODEX_BIN"
    return 0
  fi

  if have_cmd codex && codex --help >/dev/null 2>&1; then
    echo "codex"
    return 0
  fi

  if have_cmd codex; then
    local real pkgroot candidate
    real="$(readlink -f "$(command -v codex)" 2>/dev/null || command -v codex)"
    pkgroot="$(dirname "$(dirname "$real")")"
    candidate="$pkgroot/vendor/x86_64-unknown-linux-musl/codex/codex"
    if [[ -x "$candidate" ]]; then
      echo "$candidate"
      return 0
    fi
  fi

  local fallback
  fallback="$(ls -1 "$HOME"/.nvm/versions/node/*/lib/node_modules/@openai/codex/vendor/*/codex/codex 2>/dev/null | head -n 1 || true)"
  if [[ -n "$fallback" && -x "$fallback" ]]; then
    echo "$fallback"
    return 0
  fi

  die "cannot find working codex binary; set CODEX_SWITCH_CODEX_BIN to the native 'codex' executable"
}

normalize_auth_mode() {
  local mode="$1"
  mode="$(echo "$mode" | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')"
  case "$mode" in
    1|copy) echo "copy" ;;
    2|from) echo "from" ;;
    3|paste) echo "paste" ;;
    4|edit) echo "edit" ;;
    5|empty) echo "empty" ;;
    *) echo "$mode" ;;
  esac
}

trim_ws() {
  echo "$1" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//'
}

current_base_url() {
  local cfg mp
  cfg="$(codex_home)/config.toml"
  [[ -f "$cfg" ]] || return 0

  mp="$(toml_get_string "$cfg" "model_provider")"
  [[ -n "$mp" ]] || return 0

  toml_get_provider_base_url "$cfg" "$mp"
}

shared_provider_name() {
  if [[ -n "${CODEX_SWITCH_SHARED_PROVIDER:-}" ]]; then
    echo "$CODEX_SWITCH_SHARED_PROVIDER"
    return 0
  fi

  local cfg mp
  cfg="$(codex_home)/config.toml"
  if [[ -f "$cfg" ]]; then
    mp="$(toml_get_string "$cfg" "model_provider")"
    if [[ -n "$mp" ]]; then
      echo "$mp"
      return 0
    fi
  fi

  echo "shared"
}

profile_base_url() {
  local profile_cfg="$1"
  [[ -f "$profile_cfg" ]] || die "missing profile config: $profile_cfg"
  local mp url
  mp="$(toml_get_string "$profile_cfg" "model_provider")"
  [[ -n "$mp" ]] || die "missing model_provider in profile config: $profile_cfg"
  url="$(toml_get_provider_base_url "$profile_cfg" "$mp")"
  [[ -n "$url" ]] || die "missing base_url for provider '$mp' in profile config: $profile_cfg"
  echo "$url"
}

sha256_file() {
  local path="$1"
  if command -v sha256sum >/dev/null 2>&1; then
    sha256sum "$path" | awk '{print $1}'
  elif command -v shasum >/dev/null 2>&1; then
    shasum -a 256 "$path" | awk '{print $1}'
  elif command -v openssl >/dev/null 2>&1; then
    openssl dgst -sha256 "$path" | awk '{print $2}'
  else
    die "missing hash command: sha256sum/shasum/openssl"
  fi
}

fingerprint_dir() {
  local dir="$1"
  local cfg="$dir/config.toml"
  local auth="$dir/auth.json"
  [[ -f "$cfg" ]] || die "missing $cfg"
  [[ -f "$auth" ]] || die "missing $auth"
  printf "%s:%s\n" "$(sha256_file "$cfg")" "$(sha256_file "$auth")"
}

backup_limit() {
  local limit="${CODEX_SWITCH_BACKUP_LIMIT:-10}"
  [[ "$limit" =~ ^[0-9]+$ ]] || die "invalid CODEX_SWITCH_BACKUP_LIMIT (must be integer): $limit"
  echo "$limit"
}

prune_backups() {
  local root limit
  root="$(backups_dir)"
  limit="$(backup_limit)"
  mkdir -p "$root"

  local -a dirs
  mapfile -t dirs < <(find "$root" -mindepth 1 -maxdepth 1 -type d -printf '%f\n' 2>/dev/null | sort)
  local n remove_count i
  n="${#dirs[@]}"
  if (( n <= limit )); then
    return 0
  fi
  remove_count=$((n - limit))
  for ((i = 0; i < remove_count; i++)); do
    rm -rf -- "$root/${dirs[$i]}"
  done
}

validate_profile_name() {
  local name="$1"
  [[ -n "$name" ]] || die "profile name required"
  [[ "$name" != *"/"* ]] || die "invalid profile name (must not contain '/'): $name"
  [[ "$name" != "." && "$name" != ".." ]] || die "invalid profile name: $name"
}

codex_home() {
  if [[ -n "${CODEX_HOME:-}" ]]; then
    echo "$CODEX_HOME"
  else
    echo "$HOME/.codex"
  fi
}

switch_root() {
  echo "${CODEX_SWITCH_HOME:-$HOME/.codex-switch}"
}

profiles_dir() {
  echo "$(switch_root)/profiles"
}

state_dir() {
  echo "$(switch_root)/state"
}

backups_dir() {
  echo "$(switch_root)/backups"
}

lock_path() {
  echo "$(switch_root)/.lock"
}

with_lock() {
  (
    local lock_file
    lock_file="$(lock_path)"
    mkdir -p "$(dirname "$lock_file")"
    if command -v flock >/dev/null 2>&1; then
      exec 9>"$lock_file"
      flock -x 9
      "$@"
    else
      "$@"
    fi
  )
}

ensure_dirs() {
  mkdir -p "$(profiles_dir)" "$(state_dir)" "$(backups_dir)"
}

current_profile_file() {
  echo "$(state_dir)/current"
}

read_current_profile() {
  local f
  f="$(current_profile_file)"
  if [[ -r "$f" ]]; then
    tr -d '\n' <"$f"
  else
    echo ""
  fi
}

write_current_profile() {
  local name="$1"
  ensure_dirs
  printf "%s\n" "$name" >"$(current_profile_file)"
}

profile_path() {
  local name="$1"
  echo "$(profiles_dir)/$name"
}

require_profile_exists() {
  local name="$1"
  local dir
  dir="$(profile_path "$name")"
  [[ -d "$dir" ]] || die "profile not found: $name (expected dir: $dir)"
  [[ -f "$dir/config.toml" ]] || die "missing $dir/config.toml"
  [[ -f "$dir/auth.json" ]] || die "missing $dir/auth.json"
}

require_codex_files_exist() {
  local ch
  ch="$(codex_home)"
  [[ -d "$ch" ]] || die "codex home not found: $ch (set CODEX_HOME to override)"
  [[ -f "$ch/config.toml" ]] || die "missing $ch/config.toml"
  [[ -f "$ch/auth.json" ]] || die "missing $ch/auth.json"
}

profile_is_active() {
  local name="$1"
  local ch pdir
  ch="$(codex_home)"
  pdir="$(profile_path "$name")"
  [[ -f "$ch/config.toml" && -f "$ch/auth.json" ]] || return 1
  [[ -f "$pdir/config.toml" && -f "$pdir/auth.json" ]] || return 1

  if [[ "$(use_mode)" == "copy" ]]; then
    [[ "$(fingerprint_dir "$ch")" == "$(fingerprint_dir "$pdir")" ]]
    return $?
  fi

  # patch mode: match auth.json + (shared provider base_url)
  if [[ "$(sha256_file "$ch/auth.json")" != "$(sha256_file "$pdir/auth.json")" ]]; then
    return 1
  fi

  local provider cur_url prof_url
  provider="$(shared_provider_name)"
  cur_url="$(toml_get_provider_base_url "$ch/config.toml" "$provider")"
  [[ -n "$cur_url" ]] || return 1
  prof_url="$(profile_base_url "$pdir/config.toml")"
  [[ "$cur_url" == "$prof_url" ]]
}

write_file_atomic() {
  local dest="$1"
  local mode="$2"
  local dest_dir base tmp
  dest_dir="$(dirname "$dest")"
  base="$(basename "$dest")"
  mkdir -p "$dest_dir"
  tmp="$(mktemp -p "$dest_dir" ".${base}.tmp.XXXXXX")"
  cat >"$tmp"
  chmod "$mode" "$tmp"
  mv -f "$tmp" "$dest"
}

write_file_atomic_stripping_bracketed_paste() {
  local dest="$1"
  local mode="$2"
  local dest_dir base tmp
  dest_dir="$(dirname "$dest")"
  base="$(basename "$dest")"
  mkdir -p "$dest_dir"
  tmp="$(mktemp -p "$dest_dir" ".${base}.tmp.XXXXXX")"
  sed $'s/\\x1b\\[200~//g; s/\\x1b\\[201~//g' >"$tmp"
  chmod "$mode" "$tmp"
  mv -f "$tmp" "$dest"
}

set_toml_key() {
  local file="$1"
  local key="$2"
  local value="$3"
  local tmp
  tmp="$(mktemp)"

  # Update a *root-level* key only (before the first table header). This avoids accidentally
  # changing similarly-named keys under other tables like [features], which may expect booleans.
  awk -v key="$key" -v value="$value" '
    BEGIN { done=0; before_tables=1 }
    before_tables && $0 ~ "^" key "[ \t]*=" && !done {
      print key " = \"" value "\""
      done=1
      next
    }
    before_tables && $0 ~ /^\[/ && !done {
      print key " = \"" value "\""
      done=1
    }
    $0 ~ /^\[/ { before_tables=0 }
    { print }
    END {
      if (!done) print key " = \"" value "\""
    }
  ' "$file" >"$tmp"
  cat "$tmp" | write_file_atomic "$file" 600
  rm -f "$tmp"
}

ensure_provider_block() {
  local file="$1"
  local provider="$2"
  local base_url="$3"
  local header="[model_providers.$provider]"

  if grep -qxF "$header" "$file"; then
    local tmp
    tmp="$(mktemp)"
    awk -v header="$header" -v base_url="$base_url" -v provider="$provider" '
      BEGIN { inside=0; wrote_base=0; wrote_name=0 }
      $0==header { print; inside=1; next }
      inside && /^base_url[ \t]*=/ { print "base_url = \"" base_url "\""; wrote_base=1; next }
      inside && /^name[ \t]*=/ { print "name = \"" provider "\""; wrote_name=1; next }
      inside && /^\[/ {
        if (!wrote_name) { print "name = \"" provider "\""; wrote_name=1 }
        if (!wrote_base) { print "base_url = \"" base_url "\""; wrote_base=1 }
        inside=0
      }
      { print }
      END {
        if (inside && !wrote_name) print "name = \"" provider "\""
        if (inside && !wrote_base) print "base_url = \"" base_url "\""
      }
    ' "$file" >"$tmp"
    cat "$tmp" | write_file_atomic "$file" 600
    rm -f "$tmp"
    return 0
  fi

  cat >>"$file" <<EOF

[model_providers.$provider]
name = "$provider"
base_url = "$base_url"
wire_api = "responses"
requires_openai_auth = true
EOF
  chmod 600 "$file"
}

toml_table_exists() {
  local file="$1"
  local header="$2"
  grep -qxF "$header" "$file"
}

toml_delete_table() {
  local file="$1"
  local header="$2"
  local tmp
  tmp="$(mktemp)"
  awk -v header="$header" '
    BEGIN { skip=0 }
    $0==header { skip=1; next }
    skip && /^\[/ { skip=0 }
    !skip { print }
  ' "$file" >"$tmp"
  cat "$tmp" | write_file_atomic "$file" 600
  rm -f "$tmp"
}

toml_rename_table() {
  local file="$1"
  local old_header="$2"
  local new_header="$3"
  local provider="$4"
  local tmp
  tmp="$(mktemp)"
  awk -v old_header="$old_header" -v new_header="$new_header" -v provider="$provider" '
    BEGIN { inside=0 }
    $0==old_header { print new_header; inside=1; next }
    inside && /^\[/ { inside=0 }
    inside && /^name[ \t]*=/ { print "name = \"" provider "\""; next }
    { print }
  ' "$file" >"$tmp"
  cat "$tmp" | write_file_atomic "$file" 600
  rm -f "$tmp"
}

normalize_right_provider_table() {
  local file="$1"
  local mp
  mp="$(toml_get_string "$file" "model_provider")"
  [[ -n "$mp" ]] || return 0
  [[ "$mp" != "right" ]] || return 0

  local right_header mp_header
  right_header="[model_providers.right]"
  mp_header="[model_providers.$mp]"

  if toml_table_exists "$file" "$right_header"; then
    if toml_table_exists "$file" "$mp_header"; then
      toml_delete_table "$file" "$right_header"
    else
      toml_rename_table "$file" "$right_header" "$mp_header" "$mp"
    fi
  fi
}

copy_atomic() {
  local src="$1"
  local dest="$2"
  local mode="$3"
  local dest_dir base tmp
  dest_dir="$(dirname "$dest")"
  base="$(basename "$dest")"
  mkdir -p "$dest_dir"
  tmp="$(mktemp -p "$dest_dir" ".${base}.tmp.XXXXXX")"
  cp -f "$src" "$tmp"
  chmod "$mode" "$tmp"
  mv -f "$tmp" "$dest"
}

backup_current() {
  local label="$1"
  local ch root ts bdir
  ch="$(codex_home)"
  root="$(backups_dir)"
  ts="$(date +%Y%m%d-%H%M%S)"
  bdir="$root/$ts-$label"
  mkdir -p "$bdir"

  if [[ -f "$ch/config.toml" ]]; then
    copy_atomic "$ch/config.toml" "$bdir/config.toml" 600
  fi
  if [[ -f "$ch/auth.json" ]]; then
    copy_atomic "$ch/auth.json" "$bdir/auth.json" 600
  fi
  printf "%s\n" "$bdir" >"$(state_dir)/last_backup"
  prune_backups
}

backup_profile_configs() {
  local label="$1"
  local root ts bdir
  root="$(backups_dir)"
  ts="$(date +%Y%m%d-%H%M%S)"
  bdir="$root/$ts-$label"
  mkdir -p "$bdir"

  local p name cfg
  for p in "$(profiles_dir)"/*; do
    [[ -d "$p" ]] || continue
    name="$(basename "$p")"
    cfg="$p/config.toml"
    [[ -f "$cfg" ]] || continue
    mkdir -p "$bdir/$name"
    copy_atomic "$cfg" "$bdir/$name/config.toml" 600
  done

  echo "$bdir"
}

do_init() {
  ensure_dirs
  echo "OK: initialized at $(switch_root)"
}

do_list() {
  ensure_dirs
  local d
  d="$(profiles_dir)"
  if [[ ! -d "$d" ]]; then
    exit 0
  fi
  (cd "$d" && ls -1) 2>/dev/null || true
}

do_current() {
  ensure_dirs
  local cur
  cur="$(read_current_profile)"

  if [[ -n "$cur" ]] && profile_is_active "$cur" 2>/dev/null; then
    echo "$cur"
    return 0
  fi

  local p name
  for p in "$(profiles_dir)"/*; do
    [[ -d "$p" ]] || continue
    name="$(basename "$p")"
    if profile_is_active "$name" 2>/dev/null; then
      write_current_profile "$name"
      echo "$name"
      return 0
    fi
  done

  echo "(unknown)"
}

do_path() {
  cat <<EOF
CODEX_HOME=$(codex_home)
CODEX_SWITCH_HOME=$(switch_root)
profiles=$(profiles_dir)
EOF
}

do_save() {
  local name="$1"
  validate_profile_name "$name"
  ensure_dirs
  require_codex_files_exist

  local ch pdir
  ch="$(codex_home)"
  pdir="$(profile_path "$name")"
  mkdir -p "$pdir"

  copy_atomic "$ch/config.toml" "$pdir/config.toml" 600
  copy_atomic "$ch/auth.json" "$pdir/auth.json" 600
  echo "OK: saved profile '$name' -> $pdir"
}

do_add() {
  local name="$1"
  shift || true
  validate_profile_name "$name"
  ensure_dirs
  require_codex_files_exist

  local provider="" base_url="" auth_mode="" auth_from="" do_switch="no" force="no" yes="no"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --provider)
        [[ $# -ge 2 ]] || die "missing value for --provider"
        provider="$2"; shift 2
        ;;
      --base-url)
        [[ $# -ge 2 ]] || die "missing value for --base-url"
        base_url="$2"; shift 2
        ;;
      --copy-auth)
        auth_mode="copy"; shift
        ;;
      --no-copy-auth)
        auth_mode="empty"; shift
        ;;
      --auth-empty)
        auth_mode="empty"; shift
        ;;
      --auth-copy)
        auth_mode="copy"; shift
        ;;
      --auth-from)
        [[ $# -ge 2 ]] || die "missing value for --auth-from"
        auth_mode="from"; auth_from="$2"; shift 2
        ;;
      --auth-paste)
        auth_mode="paste"; shift
        ;;
      --auth-edit)
        auth_mode="edit"; shift
        ;;
      --switch)
        do_switch="yes"; shift
        ;;
      --force)
        force="yes"; shift
        ;;
      -y|--yes)
        yes="yes"; shift
        ;;
      -h|--help)
        usage_add
        exit 0
        ;;
      *)
        die "unknown option for add: $1"
        ;;
    esac
  done

  local pdir wdir success
  pdir="$(profile_path "$name")"
  if [[ -e "$pdir" && "$force" != "yes" ]]; then
    die "profile already exists: $name (use 'save' or pass --force)"
  fi

  wdir="$(mktemp -d -p "$(profiles_dir)" ".${name}.tmp.XXXXXX")"
  success="no"
  cleanup_add() {
    if [[ "${success:-no}" != "yes" && -n "${wdir:-}" && -d "${wdir:-}" ]]; then
      rm -rf -- "$wdir"
    fi
  }
  trap cleanup_add EXIT INT TERM

  local ch
  ch="$(codex_home)"
  copy_atomic "$ch/config.toml" "$wdir/config.toml" 600

  local old_provider
  old_provider="$(toml_get_string "$wdir/config.toml" "model_provider")"

  local default_provider default_base_url input
  if [[ "$(use_mode)" == "patch" ]]; then
    default_provider="$(shared_provider_name)"
  else
    default_provider="${CODEX_SWITCH_SHARED_PROVIDER:-$name}"
  fi
  if [[ -z "$provider" ]]; then
    if [[ "$yes" == "yes" ]]; then
      provider="$default_provider"
    else
      provider="$(prompt "Provider name" "$default_provider")"
    fi
  fi
  provider="$(trim_ws "$provider")"
  [[ "$provider" =~ ^[A-Za-z0-9_-]+$ ]] || die "invalid provider name: $provider (allowed: [A-Za-z0-9_-]+)"

  default_base_url="$(current_base_url)"
  if [[ -z "$base_url" ]]; then
    if [[ "$yes" == "yes" && -n "$default_base_url" ]]; then
      base_url="$default_base_url"
    else
      base_url="$(prompt "base_url" "$default_base_url")"
    fi
  fi
  base_url="$(trim_ws "$base_url")"
  [[ -n "$base_url" ]] || die "base_url required"

  # If the source config only has [model_providers.right], keep it in sync when switching away.
  if [[ "$old_provider" == "right" && "$provider" != "right" ]]; then
    local right_header new_header
    right_header="[model_providers.right]"
    new_header="[model_providers.$provider]"
    if toml_table_exists "$wdir/config.toml" "$right_header"; then
      if toml_table_exists "$wdir/config.toml" "$new_header"; then
        toml_delete_table "$wdir/config.toml" "$right_header"
      else
        toml_rename_table "$wdir/config.toml" "$right_header" "$new_header" "$provider"
      fi
    fi
  fi

  set_toml_key "$wdir/config.toml" "model_provider" "$provider"
  ensure_provider_block "$wdir/config.toml" "$provider" "$base_url"

  if [[ -z "$auth_mode" ]]; then
    if [[ "$yes" == "yes" ]]; then
      auth_mode="copy"
    else
      term_printf "auth: paste API key (input hidden). Press Enter to copy current auth.json.\n"
      local api_key
      api_key="$(prompt_secret "auth")"
      if [[ -z "$api_key" ]]; then
        auth_mode="copy"
      else
        auth_mode="api_key"
        auth_from="$api_key"
      fi
    fi
  fi
  auth_mode="$(normalize_auth_mode "$auth_mode")"

  case "$auth_mode" in
    copy)
      copy_atomic "$ch/auth.json" "$wdir/auth.json" 600
      ;;
    api_key|apikey|key)
      local codex_bin
      codex_bin="$(codex_native_bin)"
      # Writes auth.json using Codex itself to avoid guessing schema. Reads key from stdin.
      # Do NOT print the key; keep it in-memory only.
      printf '%s\n' "$auth_from" | CODEX_HOME="$wdir" "$codex_bin" login --with-api-key >/dev/null
      chmod 600 "$wdir/auth.json" 2>/dev/null || true
      ;;
    empty)
      printf "%s\n" "{}" | write_file_atomic "$wdir/auth.json" 600
      ;;
    from)
      if [[ -z "$auth_from" ]]; then
        if [[ "$yes" == "yes" ]]; then
          die "--auth-from requires a path (or choose another mode)"
        fi
        auth_from="$(prompt "Path to auth.json to copy")"
      fi
      [[ -f "$auth_from" ]] || die "auth file not found: $auth_from"
      copy_atomic "$auth_from" "$wdir/auth.json" 600
      ;;
    paste)
      if [[ "$yes" == "yes" ]]; then
        die "--auth-paste requires stdin input (omit -y for interactive)"
      fi
      echo "Paste auth.json content now, then press Ctrl-D to finish:" >&2
      write_file_atomic_stripping_bracketed_paste "$wdir/auth.json" 600
      ;;
    edit)
      copy_atomic "$ch/auth.json" "$wdir/auth.json" 600
      local editor
      editor="${EDITOR:-${VISUAL:-}}"
      if [[ -z "$editor" ]]; then
        if have_cmd nano; then editor="nano"
        elif have_cmd vi; then editor="vi"
        else die "no editor found; set EDITOR or use another auth mode"
        fi
      fi
      "$editor" "$wdir/auth.json"
      ;;
    *)
      die "invalid auth mode: $auth_mode (expected copy/from/paste/edit/empty)"
      ;;
  esac

  if [[ -e "$pdir" && "$force" == "yes" ]]; then
    rm -rf -- "$pdir"
  fi
  mv -f -- "$wdir" "$pdir"
  success="yes"
  trap - EXIT INT TERM

  echo "OK: added profile '$name' -> $pdir"
  if [[ "$do_switch" == "yes" ]]; then
    do_use "$name"
  fi
}

do_del() {
  local name="$1"
  shift || true
  validate_profile_name "$name"
  ensure_dirs

  local yes="no"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -y|--yes|--force)
        yes="yes"; shift
        ;;
      -h|--help)
        cat <<'EOF'
Usage:
  codex-switch del <profile> [-y|--yes|--force]

Notes:
  - Deletes profile directory under ~/.codex-switch/profiles/<profile>
  - If profile is recorded as current, clears ~/.codex-switch/state/current
EOF
        exit 0
        ;;
      *)
        die "unknown option for del: $1"
        ;;
    esac
  done

  local pdir
  pdir="$(profile_path "$name")"
  [[ -d "$pdir" ]] || die "profile not found: $name"

  if [[ "$yes" != "yes" ]]; then
    local ans
    ans="$(prompt "Delete profile '$name'? Type 'yes' to confirm" "")"
    [[ "$ans" == "yes" ]] || die "aborted"
  fi

  rm -rf -- "$pdir"

  if [[ "$(read_current_profile)" == "$name" ]]; then
    printf "%s\n" "" >"$(current_profile_file)"
  fi

  echo "OK: deleted profile '$name'"
}

do_edit() {
  local name="$1"
  local old_name="$1"
  shift || true
  validate_profile_name "$name"
  ensure_dirs
  require_profile_exists "$name"

  local yes="no"
  local rename="no"
  local was_current="no"
  if [[ "$(read_current_profile)" == "$name" ]]; then
    was_current="yes"
  fi
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --rename)
        rename="yes"; shift
        ;;
      -y|--yes)
        yes="yes"; shift
        ;;
      -h|--help)
        cat <<'EOF'
Usage:
  codex-switch edit <profile> [--rename] [-y]

Notes:
  - Opens profile config.toml and auth.json in $EDITOR (or nano/vi fallback)
  - With --rename, prompts for a new profile name and renames the profile directory first
  - If the profile is current, re-applies it to CODEX_HOME after edit
EOF
        exit 0
        ;;
      *)
        die "unknown option for edit: $1"
        ;;
    esac
  done

  if [[ "$rename" == "yes" ]]; then
    local new_name
    term_printf "%s" "New profile name: "
    if [[ -t 0 ]]; then
      if ! IFS= read -r -e new_name; then
        IFS= read -r new_name || die "input aborted"
      fi
    else
      IFS= read -r new_name || die "input aborted"
    fi
    new_name="$(sanitize_terminal_input "$new_name")"
    validate_profile_name "$new_name"

    local old_dir new_dir
    old_dir="$(profile_path "$name")"
    new_dir="$(profile_path "$new_name")"
    [[ ! -e "$new_dir" ]] || die "profile already exists: $new_name"

    mv -- "$old_dir" "$new_dir"
    name="$new_name"
    if [[ "$yes" != "yes" ]]; then
      echo "OK: renamed profile '$old_name' -> '$name'" >&2
    fi
  fi

  local pdir cfg auth editor
  pdir="$(profile_path "$name")"
  cfg="$pdir/config.toml"
  auth="$pdir/auth.json"

  editor="${EDITOR:-${VISUAL:-}}"
  if [[ -z "$editor" ]]; then
    if have_cmd nano; then editor="nano"
    elif have_cmd vi; then editor="vi"
    else die "no editor found; set EDITOR"
    fi
  fi

  if [[ "$yes" != "yes" ]]; then
    echo "Editing $cfg" >&2
  fi
  "$editor" "$cfg"
  chmod 600 "$cfg" || true

  if [[ "$yes" != "yes" ]]; then
    echo "Editing $auth" >&2
  fi
  "$editor" "$auth"
  chmod 600 "$auth" || true

  if [[ "$was_current" == "yes" ]]; then
    do_use "$name"
  fi

  echo "OK: edited profile '$name'"
}

do_use() {
  local name="$1"
  validate_profile_name "$name"
  ensure_dirs
  require_profile_exists "$name"

  # Keep profiles clean: if model_provider != right, don't keep a stale [model_providers.right] block.
  normalize_right_provider_table "$(profile_path "$name")/config.toml"

  if profile_is_active "$name" 2>/dev/null; then
    write_current_profile "$name"
    normalize_right_provider_table "$(codex_home)/config.toml"
    echo "OK: already using '$name'"
    exit 0
  fi

  local ch pdir
  ch="$(codex_home)"
  pdir="$(profile_path "$name")"
  mkdir -p "$ch"

  backup_current "before-$name"

  if [[ "$(use_mode)" == "copy" ]]; then
    copy_atomic "$pdir/config.toml" "$ch/config.toml" 600
    copy_atomic "$pdir/auth.json" "$ch/auth.json" 600
    normalize_right_provider_table "$ch/config.toml"
    write_current_profile "$name"
    echo "OK: switched to '$name' (backed up previous to $(cat "$(state_dir)/last_backup"))"
    return 0
  fi

  # patch mode: keep a single config.toml and only patch provider base_url + model_provider.
  require_codex_files_exist

  local provider base_url
  provider="$(shared_provider_name)"
  base_url="$(profile_base_url "$pdir/config.toml")"

  ensure_provider_block "$ch/config.toml" "$provider" "$base_url"
  set_toml_key "$ch/config.toml" "model_provider" "$provider"
  copy_atomic "$pdir/auth.json" "$ch/auth.json" 600
  normalize_right_provider_table "$ch/config.toml"
  write_current_profile "$name"

  echo "OK: switched to '$name' (patched provider='$provider', backed up previous to $(cat "$(state_dir)/last_backup"))"
}

do_unify_provider() {
  local provider="$1"
  shift || true
  provider="$(trim_ws "$provider")"
  if [[ -z "$provider" || "$provider" == "-h" || "$provider" == "--help" ]]; then
    usage_unify_provider
    exit 0
  fi
  [[ "$provider" =~ ^[A-Za-z0-9_-]+$ ]] || die "invalid provider name: $provider (allowed: [A-Za-z0-9_-]+)"

  local yes="no"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -y|--yes)
        yes="yes"; shift
        ;;
      -h|--help)
        usage_unify_provider
        exit 0
        ;;
      *)
        die "unknown option for unify-provider: $1"
        ;;
    esac
  done

  ensure_dirs
  local backup_dir
  backup_dir="$(backup_profile_configs "before-unify-provider-$provider")"
  if [[ "$yes" != "yes" ]]; then
    echo "Backup created at: $backup_dir" >&2
    echo "This will rewrite model_provider in all profiles to '$provider'." >&2
    local ans
    ans="$(prompt "Continue? Type 'yes' to confirm" "")"
    [[ "$ans" == "yes" ]] || die "aborted"
  fi

  local changed=0 skipped=0
  local p name cfg mp base_url
  for p in "$(profiles_dir)"/*; do
    [[ -d "$p" ]] || continue
    name="$(basename "$p")"
    cfg="$p/config.toml"
    if [[ ! -f "$cfg" ]]; then
      skipped=$((skipped + 1))
      continue
    fi

    mp="$(toml_get_string "$cfg" "model_provider")"
    if [[ -z "$mp" ]]; then
      echo "WARN: $name: missing model_provider in $cfg (skipped)" >&2
      skipped=$((skipped + 1))
      continue
    fi

    base_url="$(toml_get_provider_base_url "$cfg" "$mp")"
    if [[ -z "$base_url" ]]; then
      echo "WARN: $name: missing base_url for provider '$mp' in $cfg (skipped)" >&2
      skipped=$((skipped + 1))
      continue
    fi

    ensure_provider_block "$cfg" "$provider" "$base_url"
    set_toml_key "$cfg" "model_provider" "$provider"
    changed=$((changed + 1))
  done

  echo "OK: unified provider to '$provider' (changed: $changed, skipped: $skipped)"
  echo "Tip: run 'codex resume --all' to see all sessions (disables cwd filtering)."
}

do_rollback() {
  ensure_dirs
  local f bdir ch
  f="$(state_dir)/last_backup"
  [[ -r "$f" ]] || die "no last backup found (nothing to rollback)"
  bdir="$(tr -d '\n' <"$f")"
  [[ -d "$bdir" ]] || die "backup dir missing: $bdir"
  [[ -f "$bdir/config.toml" ]] || die "backup missing config.toml: $bdir"
  [[ -f "$bdir/auth.json" ]] || die "backup missing auth.json: $bdir"

  ch="$(codex_home)"
  mkdir -p "$ch"
  copy_atomic "$bdir/config.toml" "$ch/config.toml" 600
  copy_atomic "$bdir/auth.json" "$ch/auth.json" 600
  printf "%s\n" "" >"$(current_profile_file)"
  echo "OK: rolled back from $bdir"
}

main() {
  require_cmd awk
  require_cmd cat
  require_cmd cp
  require_cmd find
  require_cmd sort
  require_cmd rm
  require_cmd mv
  require_cmd mkdir
  require_cmd mktemp
  require_cmd chmod
  require_cmd date
  require_cmd sed

  local cmd="${1:-}"
  case "$cmd" in
    ""|-h|--help|help)
      usage
      ;;
    init)
      with_lock do_init
      ;;
    list)
      do_list
      ;;
    current)
      do_current
      ;;
    path)
      do_path
      ;;
    save)
      [[ $# -eq 2 ]] || die "usage: $PROG save <profile>"
      with_lock do_save "$2"
      ;;
    add)
      if [[ $# -eq 2 && ( "$2" == "-h" || "$2" == "--help" ) ]]; then
        usage_add
        exit 0
      fi
      [[ $# -ge 2 ]] || die "usage: $PROG add <profile> [options]"
      shift
      with_lock do_add "$@"
      ;;
    del)
      [[ $# -ge 2 ]] || die "usage: $PROG del <profile>"
      shift
      with_lock do_del "$@"
      ;;
    edit)
      [[ $# -ge 2 ]] || die "usage: $PROG edit <profile>"
      shift
      with_lock do_edit "$@"
      ;;
    use)
      [[ $# -eq 2 ]] || die "usage: $PROG use <profile>"
      with_lock do_use "$2"
      ;;
    unify-provider)
      [[ $# -ge 2 ]] || die "usage: $PROG unify-provider <provider> [-y|--yes]"
      shift
      with_lock do_unify_provider "$@"
      ;;
    rollback)
      with_lock do_rollback
      ;;
    *)
      die "unknown command: $cmd (run '$PROG --help')"
      ;;
  esac
}

main "$@"
